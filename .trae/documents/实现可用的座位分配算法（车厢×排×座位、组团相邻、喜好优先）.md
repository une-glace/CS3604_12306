## 目标
- 满足 8 节车厢 × 每节 1–16 排 × 每排 ABC·DE（C/D 中间为过道）的座位模型。
- 返回座位号采用“X车Y排Z”的字符串格式，例如“3车13D”。
- 组团订票尽量安排同排相邻；若同排无法满足，则同车厢临近排；再退化为跨车厢。
- 遵循订单核对窗口的席位喜好（A/B/C/D/E），尽量满足；不足则随机分配但不重复。
- 每次完成订单后，已分配座位写入 `order_passengers.seat_number`；取消/退票释放座位，避免重复分配。

## 数据与现状核对
- 已有表 `order_passengers`：含 `seat_type` 与 `seat_number`，可写入座位号，无需改表。
- 可用余票以 `train_seats.availableSeats` 维护（按座位类型计数）；本次分配按座位号维度仅依赖 `order_passengers` 去重。
- 取消订单时已将 `availableSeats` 回增，且当前分配占用座位仅筛选 `status in ['unpaid','paid','completed']`，不会被 `cancelled/refunded` 影响。

## 后端实现方案
### 1. 座位模型生成（纯函数）
- 生成全量座位集合：
  - 车厢编号：`1..8`
  - 排号：`1..16`
  - 座位字母：`['A','B','C','D','E']`
  - 字符串：`${car}车${row}排${letter}`（保持与用户要求一致）
- 分别用于每种 `seat_type`；若不同席别共用同一模型，直接复用（与现实不同，但满足题设）。

### 2. 已占用座位集合（按车次+日期+席别）
- 查询 `order_passengers` + `orders`：`trainNumber` + `departureDate` + `seatType` 且 `status in ['unpaid','paid','completed']`
- `occupied = Set(orderPassenger.seatNumber)`

### 3. 组团分配算法（满足喜好、相邻、退化策略）
- 输入：`seatTypeList[]`（按乘客顺序）、`preferences[]`（可能为空，值为 'A'|'B'|'C'|'D'|'E'）、`occupiedSet`、`seatUniverse`（全量座位）
- 过程：
  1) 将同席别乘客聚类（通常同单为同席别，支持混合）：对每个席别单独分配。
  2) 对每个席别的分配：
     - 优先策略：同排相邻优先；相邻定义为左块 `[A,B,C]` 或右块 `[D,E]` 内连续、或跨过道的就近（如 `C-D`）
     - 先尝试在同一排中找到能同时容纳 `n` 个座位的组合；若乘客有喜好，则组合中优先包含喜好座位并按乘客顺序分配
     - 若同排不满足：在同车厢相邻排搜索（例如当前排±1、±2），仍尽量靠拢
     - 若仍不满足：跨车厢按 `car=1..8` 顺序搜索，选择最近可用的组合
     - 全部失败：对剩余未满足的乘客进行随机分配（从 `seatUniverse - occupiedSet` 取最早可用）
- 输出：与乘客顺序一一对应的 `seatNumber[]`

### 4. 接入点与改动文件
- `backend/src/controllers/orderController.js`
  - 替换 `allocateSeat` 为新的 `allocateSeatsForGroup(trainNumber, date, ticketInfos, selectedSeatCodes, transaction)`：一次性返回所有乘客的座位号数组；保留余票计数逻辑不变
  - 在创建 `order_passengers` 时使用返回的座位号
  - 保持取消订单释放余票逻辑（无需改动）；若要释放座位占用，可增加将 `seat_number` 作为参考，但由于我们查询 `occupied` 已排除取消态，不需要额外改动

### 5. 订单核对窗口的偏好输入规范
- 将现有偏好字母统一到 `A/B/C/D/E`（若目前 UI 有 `F`，改为 `E`）
- 偏好数组 `selectedSeats[]` 与乘客顺序一一对应，后端按序接收

### 6. 返回格式与前端展示
- 确认订单成功返回的 `order.passengers[].seatNumber` 为如 `3车13D` 的格式
- 订单列表与详情沿用现有字段展示，无需改动

## 关键算法伪代码
```js
function generateUniverse() {
  const seats = []
  for (let car=1; car<=8; car++) {
    for (let row=1; row<=16; row++) {
      for (const letter of ['A','B','C','D','E']) {
        seats.push(`${car}车${row}排${letter}`)
      }
    }
  }
  return seats
}

function allocateForSeatType(n, preferences, occupied, universe) {
  const leftBlock = ['A','B','C']
  const rightBlock = ['D','E']
  // 排序 universe 为 car->row->letter
  const grouped = groupByCarRow(universe)
  // 1) 同排相邻匹配（含喜好）
  for (const {car,row,seats} of grouped) {
    const available = seats.filter(s => !occupied.has(s))
    if (available.length >= n) {
      // 若有喜好，先拿喜好；不足再补同排相邻
      const chosen = pickWithPreferences(available, preferences, leftBlock, rightBlock, n)
      if (chosen) return chosen
    }
  }
  // 2) 同车厢相邻排退化
  for (const car of cars) {
    const rows = rowsByCar(car)
    const chosen = tryAdjacentRows(rows, occupied, preferences, n)
    if (chosen) return chosen
  }
  // 3) 跨车厢退化
  return pickAnyAvailable(universe, occupied, preferences, n)
}
```

## 迭代与测试计划
- 单元测试：
  - 同排 3 人（偏好 A/C/E），返回同排组合且包含偏好
  - 2 人跨过道（偏好 C/D）能同排；无偏好退化到右块 `D/E`
  - 余票不足同排，退化同车厢相邻排；再不足跨车厢
  - 已占用冲突时不重复分配
- 端到端测试：
  - 两人/三人下单，核对框座位显示如 `3车13D/3车13E/...`
  - 再次下单同一车次日期，座位不重复
- 性能注意：
  - 生成与搜索在 8×16×5 = 640 座位范围内，复杂度低
  - 仅按订单状态过滤查询占用，避免锁表；已有事务确保余票一致性

## 风险与兼容
- 现实席别座椅布局与题设不同（一等座通常 4 座），本实现按题设统一 ABCDE；如需席别差异化，可在算法中为不同 `seat_type` 定义不同 `letters`
- 现有 `seat_number` 长度 10，字符串如 `8车16排E` ≤ 8 字符，兼容

## 交付步骤
1. 后端：实现 `allocateSeatsForGroup` 与辅助函数，替换创建订单处的单座分配；返回订单含席位号
2. 前端：确认偏好字母统一为 `A/B/C/D/E`（若 UI 有 `F` 改为 `E`）
3. 测试：添加单元与 E2E；验证取消订单后不占用座位
4. 文档：在 `orderController.js` 顶部简述算法规则（仅开发注释，不暴露敏感信息）

请确认以上方案，我将开始实施后端算法与前端偏好字母统一，并补充测试。